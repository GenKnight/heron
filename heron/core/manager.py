# encoding: UTF-8
"""
This module defines the Manager class.
"""
import atexit
from collections import deque
from threading import RLock, Thread, current_thread
from signal import SIGTERM
from multiprocessing import current_process
from os import getpid
from inspect import isfunction
from sys import exc_info as _exc_info, stderr
from traceback import format_exc

from .events import Event
from ..tools import tryimport
from ..six import create_bound_method

try:
    from signal import SIGKILL
except ImportError:
    SIGKILL = SIGTERM

TIMEOUT = 0.1  # 100ms timeout when idle

# todo refactor this method to check thread ident
thread = tryimport(("thread", "_thread"))


class UnregistrableError(Exception):

    """Raised if a component cannot be registered as child."""


class _EventQueue(object):

    def __init__(self):
        self._queue = deque()

    def __len__(self):
        return len(self._queue)

    @property
    def queue(self):
        """
        Return the Event Queue. Often used in register child.
        :return:
        """
        return self._queue

    def drain_from(self, other_queue):
        self._queue.extend(other_queue.queue)
        other_queue.queue.clear()

    def append(self, event):
        """append an event to the with the priority"""
        self._queue.append(event)

    def dispatch_events(self, dispatcher):
        # todo refactor priority implementation
        size = len(self._queue)
        while size:
            size -= 1
            event = self._queue.popleft()
            try:
                dispatcher(event)
            except:
                # todo add dispatcher error catch
                pass


class started(Event):

    """started Event

    This Event is sent when a Component or Manager has started running.

    :param manager: The component or manager that was started
    :type  manager: Component or Manager
    """

    def __init__(self, manager):
        super(started, self).__init__(manager)


class stopped(Event):

    """stopped Event

    This Event is sent when a Component or Manager has stopped running.

    :param manager: The component or manager that has stopped
    :type  manager: Component or Manager
    """

    def __init__(self, manager):
        super(stopped, self).__init__(manager)


class Manager(object):

    """
    The manager class has two roles. As a base class for component
    implementation, it provides methods for event and handler management.
    The method :meth:`.fireEvent` appends a new event at the end of the event
    queue for later execution. :meth:`.waitEvent` suspends the execution
    of a handler until all handlers for a given event have been invoked.
    :meth:`.callEvent` combines the last two methods in a single method.

    The methods :meth:`.addHandler` and :meth:`.removeHandler` allow handlers
    for events to be added and removed dynamically. (The more common way to
    register a handler is to use the :func:`~.handlers.handler` decorator
    or derive the class from :class:`~.components.Component`.)

    In its second role, the :class:`.Manager` takes the role of the
    event executor. Every component hierarchy has a root component that
    maintains a queue of events. Firing an event effectively means
    appending it to the event queue maintained by the root manager.
    The :meth:`.flush` method removes all pending events from the
    queue and, for each event, invokes all the handlers. Usually,
    :meth:`.flush` is indirectly invoked by :meth:`run`.

    The manager optionally provides information about the execution of
    events as automatically generated events. If an :class:`~.events.Event`
    has its :attr:`success` attribute set to True, the manager fires
    a :class:`~.events.Success` event if all handlers have been
    executed without error. Note that this event will be
    enqueued (and dispatched) immediately after the events that have been
    fired by the event's handlers. So the success event indicates both
    the successful invocation of all handlers for the event and the
    processing of the immediate follow-up events fired by those handlers.

    Sometimes it is not sufficient to know that an event and its
    immediate follow-up events have been processed. Rather, it is
    important to know when all state changes triggered by an event,
    directly or indirectly, have been performed. This also includes
    the processing of events that have been fired when invoking
    the handlers for the follow-up events and the processing of events
    that have again been fired by those handlers and so on. The completion
    of the processing of an event and all its direct or indirect
    follow-up events may be indicated by a :class:`~.events.Complete`
    event. This event is generated by the manager if :class:`~.events.Event`
    has its :attr:`complete` attribute set to True.

    Apart from the event queue, the root manager also maintains a list of
    tasks, actually Python generators, that are updated when the event queue
    has been flushed.
    """

    _currently_handling = None
    """
    The event currently being handled.
    """

    def __init__(self, *args, **kwargs):
        "initializes x; see x.__class__.__doc__ for signature"

        self._queue = _EventQueue()

        self._cache = dict()
        self._handlers = dict()

        self._flush_batch = 0
        self._cache_needs_refresh = False

        self._executing_thread = None
        self._flushing_thread = None
        self._running = False
        self.__thread = None
        self.__process = None
        self._lock = RLock()

        self.root = self.parent = self
        self.components = set()

    def __nonzero__(self):
        "x.__nonzero__() <==> bool(x)"

        return True

    __bool__ = __nonzero__

    def __repr__(self):
        "x.__repr__() <==> repr(x)"

        name = self.__class__.__name__

        q = len(self._queue)
        state = "R" if self.running else "S"

        pid = current_process().pid

        if pid:
            id = "%s:%s" % (pid, current_thread().getName())
        else:
            id = current_thread().getName()

        format = "<%s %s (queued=%d) [%s]>"
        return format % (name, id, q, state)

    def __contains__(self, y):
        """x.__contains__(y) <==> y in x

        Return True if the Component y is registered.
        """

        components = self.components.copy()
        return y in components or y in [c.__class__ for c in components]

    def __len__(self):
        """x.__len__() <==> len(x)

        Returns the number of events in the Event Queue.
        """

        return len(self._queue)

    @property
    def name(self):
        """Return the name of this Component/Manager"""

        return self.__class__.__name__

    @property
    def running(self):
        """Return the running state of this Component/Manager"""

        return self._running

    @property
    def pid(self):
        """Return the process id of this Component/Manager"""

        return getpid() if self.__process is None else self.__process.pid

    @property
    def queue(self):
        """
        Return the Event Queue. Often used in register child.
        :return:
        """
        return self._queue

    def get_handlers(self, event):
        """
        Get registered handlers by event
        :param event:
        :return:
        """
        name = event.name
        handlers = set()

        handlers.update(self._handlers.get(name, []))

        for c in self.components.copy():
            handlers.update(c.get_handlers(event))

        return handlers

    def add_handler(self, f):
        """
        Dynamic add event handler
        :param f:
        :return:
        """
        method = create_bound_method(f, self) if isfunction(f) else f

        setattr(self, method.__name__, method)

        for name in method.names:
            self._handlers.setdefault(name, set()).add(method)

        return method

    def remove_handler(self, method, event=None):
        if event is None:
            names = method.names
        else:
            names = [event]

        for name in names:
            self._handlers[name].remove(method)
            if not self._handlers[name]:
                del self._handlers[name]
                try:
                    delattr(self, method.__name__)
                except AttributeError:
                    # Handler was never part of self
                    pass

    def register_child(self, component):
        if component._executing_thread is not None:
            if self.root._executing_thread is not None:
                raise UnregistrableError()
            # todo check the safety of thread change
            self.root._executing_thread = component._executing_thread
            component._executing_thread = None
        self.components.add(component)
        # drain event queue from the child component
        self.root._queue.drain_from(component.queue)

    def unregister_child(self, component):
        # todo check if the events drained would be fired after remove components
        self.components.remove(component)

    def _fire(self, event):

        self._queue.append(event)

    def fire_event(self, event):
        """Fire an event into the system.

        :param event: The event that is to be fired.
        """
        # todo implement Promise

        self.root._fire(event)

    fire = fire_event

    def _flush(self):
        # Handle events currently on queue, but none of the newly generated
        # events. Note that _flush can be called recursively.
        old_flushing = self._flushing_thread
        try:
            self._flushing_thread = current_thread()
            self._queue.dispatch_events(self._dispatcher)
        finally:
            self._flushing_thread = old_flushing

    def flush_events(self):
        """
        Flush all Events in the Event Queue. If called on a manager
        that is not the root of an object hierarchy, the invocation
        is delegated to the root manager.
        """

        self.root._flush()

    flush = flush_events

    def _dispatcher(self, event):

        event_handlers = self.get_handlers(event)

        self._currently_handling = event

        result = None

        # todo refactor event result

        for event_handler in event_handlers:
            event.handler = event_handler
            # todo refactor arguments number
            try:
                result = event_handler(event)
            except KeyboardInterrupt:
                self.stop()
            except SystemExit as e:
                self.stop(e.code)
            except:
                result = _exc_info()

                # todo raise a failure exception

            if result is not None:
                event.result = result

        self._currently_handling = None
        # todo add event done callback

    def start(self):
        """
        Start a new thread or process that invokes this manager's
        ``run()`` method. The invocation of this method returns
        immediately after the task or process has been started.
        """

        self.__thread = Thread(target=self.run, name=self.name)
        self.__thread.daemon = True
        self.__thread.start()

        return self.__thread, None

    def join(self):
        if self.__thread is not None:
            return self.__thread.join()

    def stop(self, code=None):
        """
        Stop this manager. Invoking this method causes
        an invocation of ``run()`` to return.
        """

        if not self.running:
            return

        self._running = False

        if self.root._executing_thread is None:
            for _ in range(3):
                self.flush()

        if code is not None:
            raise SystemExit(code)

    def run(self):
        """
        Run this manager. The method fires the
        :class:`~.events.Started` event and then continuously
        calls :meth:`~.tick`.

        The method returns when the manager's
        :meth:`~.stop` method is invoked.

        events and then calls :meth:`~.stop` for the manager.
        """

        atexit.register(self.stop)

        self._running = True
        self.root._executing_thread = current_thread()

        self.fire(started(self))

        try:
            while self._running or len(self._queue):
                self.flush()
            # Fading out, handle remaining work from stop event
            for _ in range(3):
                self.flush()
        except Exception as exc:
            stderr.write("Unhandled ERROR: {0:s}\n".format(exc))
            stderr.write(format_exc())
        finally:
            try:
                self.flush()
            except:
                pass

        self.root._executing_thread = None
        self.__thread = None
        self.__process = None

